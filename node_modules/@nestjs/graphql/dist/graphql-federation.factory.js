"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const common_1 = require("@nestjs/common");
const load_package_util_1 = require("@nestjs/common/utils/load-package.util");
const apollo_server_core_1 = require("apollo-server-core");
const graphql_tools_1 = require("graphql-tools");
const lodash_1 = require("lodash");
const graphql_schema_builder_1 = require("./graphql-schema-builder");
const services_1 = require("./services");
const utils_1 = require("./utils");
let GraphQLFederationFactory = class GraphQLFederationFactory {
    constructor(resolversExplorerService, delegatesExplorerService, scalarsExplorerService, gqlSchemaBuilder) {
        this.resolversExplorerService = resolversExplorerService;
        this.delegatesExplorerService = delegatesExplorerService;
        this.scalarsExplorerService = scalarsExplorerService;
        this.gqlSchemaBuilder = gqlSchemaBuilder;
    }
    mergeOptions(options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const transformSchema = (schema) => tslib_1.__awaiter(this, void 0, void 0, function* () { return options.transformSchema ? options.transformSchema(schema) : schema; });
            let schema;
            if (options.autoSchemaFile) {
                throw new Error('Code-first approach is not supported yet');
            }
            else if (lodash_1.isEmpty(options.typeDefs)) {
                schema = options.schema;
            }
            else {
                schema = this.buildSchemaFromTypeDefs(options);
            }
            return Object.assign(Object.assign({}, options), { schema: yield transformSchema(schema), typeDefs: undefined });
        });
    }
    buildSchemaFromTypeDefs(options) {
        const { buildFederatedSchema } = load_package_util_1.loadPackage('@apollo/federation', 'ApolloFederation', () => require('@apollo/federation'));
        return buildFederatedSchema([
            {
                typeDefs: apollo_server_core_1.gql `
          ${options.typeDefs}
        `,
                resolvers: this.getResolvers(options.resolvers),
            },
        ]);
    }
    generateSchema(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { buildFederatedSchema, printSchema, } = load_package_util_1.loadPackage('@apollo/federation', 'ApolloFederation', () => require('@apollo/federation'));
            const autoGeneratedSchema = yield this.gqlSchemaBuilder.buildFederatedSchema(options.autoSchemaFile, options.buildSchemaOptions, this.resolversExplorerService.getAllCtors());
            const executableSchema = buildFederatedSchema({
                typeDefs: apollo_server_core_1.gql(printSchema(autoGeneratedSchema)),
                resolvers: this.getResolvers(options.resolvers),
            });
            const schema = options.schema
                ? graphql_tools_1.mergeSchemas({
                    schemas: [options.schema, executableSchema],
                })
                : executableSchema;
            return schema;
        });
    }
    getResolvers(optionResolvers) {
        optionResolvers = Array.isArray(optionResolvers)
            ? optionResolvers
            : [optionResolvers];
        return this.extendResolvers([
            this.resolversExplorerService.explore(),
            this.delegatesExplorerService.explore(),
            ...this.scalarsExplorerService.explore(),
            ...optionResolvers,
        ]);
    }
    extendResolvers(resolvers) {
        return resolvers.reduce((prev, curr) => utils_1.extend(prev, curr), {});
    }
};
GraphQLFederationFactory = tslib_1.__decorate([
    common_1.Injectable(),
    tslib_1.__metadata("design:paramtypes", [services_1.ResolversExplorerService,
        services_1.DelegatesExplorerService,
        services_1.ScalarsExplorerService,
        graphql_schema_builder_1.GraphQLSchemaBuilder])
], GraphQLFederationFactory);
exports.GraphQLFederationFactory = GraphQLFederationFactory;
